library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use ieee.std_logic_unsigned.all;
use ieee.std_logic_arith.all;

entity test_for_light is
	Port ( clk_sys,key_s,key_r,key_m : in STD_LOGIC;
		key_shared:out std_logic;
		led_out:out std_logic_vector(7 downto 0));
end test_for_light;
architecture Behavioral of test_for_light is
	type m_vector is array(7 downto 0) of std_logic_vector(1 downto 0);
	signal clk_dis,clk_tim,clk_key,rst,sel,mode:std_logic:='0';
	signal Q1,key_s1,key_s2,key_r1,key_r2,key_m1,key_m2:std_logic:='0';
	signal tim,count_s:std_logic_vector(2 downto 0):="000";
	signal en_m:std_logic_vector(7 downto 0):=(others=>'0');
	signal en_t,clr_t,c1,ct1,ct2,ct1_2,ct3,c3_1,c3_2,c3_3:std_logic:='0'; 
	signal regout1,regout2,regout3,m1_bout,m2_bout,m3_bout,m4_bout:std_logic:='0';
	signal regm,mode_s:m_vector;
	signal led: std_logic_vector(7 downto 0):="00000000";
	signal count_m:std_logic_vector(1 downto 0):="00";
	signal decoder:std_logic_vector(7 downto 0):="00000000";
	signal cnt1,cnt3_1,cnt3_2,cnt3_3:std_logic_vector(6 downto 0):=(others=>'0');
	signal otsel1,otsel2,otsel3,flashout:std_logic:='0';
begin
	process(clk_sys)     -- 时钟分频-> 2us/500k/clk_dis
		variable cnt_sys:integer range 50 downto 0:=0;
	begin
		if clk_sys'event and clk_sys='0' then
			cnt_sys:=cnt_sys+1;
			if cnt_sys=50 then
				cnt_sys:=0;
				clk_dis<=not clk_dis;
			end if;
		end if;
	end process;
	--     clk_dis=2us///clk_tim=0.25s
	process(clk_dis,en_t)    ----时钟分频clk_key=20ms///clk_tim=0.5s
		variable cnt_tim:integer range 125000 downto 0:=0;
		variable cnt_key:integer range 5000 downto 0:=0;
	begin
		if clk_dis'event and clk_dis='0' then
			cnt_key:=cnt_key+1;					 
			if cnt_key=5000 then
				cnt_key:=0;
				clk_key<=not clk_key;
			end if;
			if en_t='0' then
				cnt_tim:=cnt_tim+1;
				if cnt_tim=125000 then
					cnt_tim:=0;
					clk_tim<=not clk_tim;
				end if;
			end if;
		end if;
	end process;
	
	--
	--
	process(clk_key,key_s,key_m,key_r)      --按键消抖扫描
	begin
		if clk_key'event and clk_key='0' then
			key_s1<=key_s;
			key_m1<=key_m;
			key_r1<=key_r;
			key_s2<=key_s1;
			key_m2<=key_m1;
			key_r2<=key_r1;
		end if;
	end process;
	sel<= key_s1 and key_s2;
	mode<=key_m1 and key_m2;
	rst<= key_r1 and key_r2;
	key_shared<='1';
	--
	--
	--
	process(sel,clk_dis,rst)     --sel触发计数器清零1
	begin 
		if clk_dis'event and clk_dis='0' then
            Q1<=sel;
		end if;
	end process;
	process(rst,sel,Q1)     --sel触发计数器清零2
	begin
	    if rst='0' then
            clr_t<=sel and (not Q1); 
        else clr_t<='1';
        end if;
    end process;
    process(tim)
    begin
    if tim(2)='0' then
    en_t<='0';
    else en_t<='1';
    end if;
    end process;
	process(clk_tim,clr_t,en_t)    ---实现2s计时和闪烁
	begin
		if clr_t='0' then
			if en_t='0' then
			if clk_tim 'event and clk_tim='0' then
				tim<=tim+1;
			end if;
			else null;
		end if;
		else	tim<="000";
		end if;
	end process;
	--
	--
	--
	process(count_s,rst)  --3-8 decoder 38译码器选择指定led的状态寄存器	
		variable decod:std_logic_vector(7 downto 0);
	begin
		if rst='0' then
			case count_s is
				when "000"=>decod:="11111110";
				when "001"=>decod:="11111101";
				when "010"=>decod:="11111011";
				when "011"=>decod:="11110111";
				when "100"=>decod:="11101111";
				when "101"=>decod:="11011111";
				when "110"=>decod:="10111111";
				when "111"=>decod:="01111111";
				when others=>decod:="11111111";
			end case;
		else
			decod:="11111111";
		end if;
		decoder<=decod;
	end process;
	---
	process(sel,rst)  ----sel选择led
	begin
		if rst='0' then
			if sel'event and sel='1' then
				count_s<=count_s+1;
				if count_s=7 then
					count_s<=(others=>'0'); 
				end if;
			end if;
		else 
			count_s<=(others=>'0');
		end if;
	end process;
	process(mode,rst)  ----mode 选择呼吸模式
	begin
		if rst='0' then
			if mode'event and mode='1' then
				count_m<=count_m+1;
				if count_m=3 then
					count_m<=(others=>'0'); 	
				end if;
			end if;
		else 
			count_m<=(others=>'0');
		end if;
	end process;
	---
	process(count_s,count_m)  ----分配模式到所选led的分支路线	
	begin
		case count_s is
			when "000" => mode_s(0)<=count_m;
			when "001" => mode_s(1)<=count_m;
			when "010" => mode_s(2)<=count_m;
			when "011" => mode_s(3)<=count_m;
			when "100" => mode_s(4)<=count_m;
			when "101" => mode_s(5)<=count_m;
			when "110" => mode_s(6)<=count_m;
			when "111" => mode_s(7)<=count_m;
			when others=>null;
		end case;
	end process;
	---
	process(mode_s,rst,en_m)  ----将当前分配器输出的值加载到寄存器
	begin
		for i in 0 to 7 loop
			if rst='0' then
				if en_m(i)='0' then
					regm(i)<=mode_s(i);
					else null;
				end if;
			else
				regm(i)<=(others=>'0');
			end if;
		end loop;
	end process;
	process(clk_dis,decoder,tim) ----生成片选使能信号
	begin
		    for i in 0 to 7 loop
			    en_m(i)<= decoder(i) or tim(2);
			end loop;
	end process;
	process(clk_tim,en_t)    ----过渡闪烁信号
	begin
	if en_t='0' then
	flashout<=clk_tim;
	else flashout<='0';
	end if;
	end process;
	-- ---根据寄存器的值选择呼吸模式输出到led
	process(clk_dis,flashout,en_m,regm,m1_bout,m2_bout,m3_bout,m4_bout)
	begin
			for i in 0 to 7 loop
				if en_m(i)='1' then
					case regm(i) is
						when "00"=>led(i)<=m1_bout;
						when "01"=>led(i)<=m2_bout;
						when "10"=>led(i)<=m3_bout;
						when "11"=>led(i)<=m4_bout;
						when others=>null;
					end case;
				else
					led(i)<=flashout;
				end if;
			end loop;
	end process;

	----占空序列内位计数
	process(clk_dis,rst)
	begin	
		if clk_dis'event and clk_dis='0' then
			if rst='0' then
				if cnt1=99 then
					cnt1<=(others=>'0');
				else
					cnt1<=cnt1+1;
				end if;
			else
				cnt1<=(others=>'0');
			end if;
		end if;
	end process;
	----占空序列循环次数计数
	process(c1,rst)----模式1
		variable cnt2:integer range 50 downto 0:=0;
	begin
		if c1'event and c1='0' then
			if rst='0' then
				if cnt2=50 then
					cnt2:=0;
					ct2<=not ct2;
				else
					cnt2:=cnt2+1;
				end if;
			else
				cnt2:=0;
				ct2<='0';
			end if;
		end if;
	end process;
	process(c1,rst)----模式2
		variable cnt2:integer range 25 downto 0:=0;
	begin
		if c1'event and c1='0' then
			if rst='0' then
				if cnt2=25 then
					cnt2:=0;
					ct1<=not ct1;
				else
					cnt2:=cnt2+1;
				end if;
			else
				cnt2:=0;
				ct1<='0';
			end if;
		end if;
	end process;
	process(c1,rst)----模式3
		variable cnt2:integer range 50 downto 0:=0;
	begin
		if c1'event and c1='0' then
			if rst='0' then
				if cnt2=50 then
					cnt2:=0;
					ct1_2<=not ct1_2;
				else
					cnt2:=cnt2+1;
				end if;
			else
				cnt2:=0;
				ct1_2<='0';
			end if;
		end if;
	end process;
	--  --  --占空比值计数
	process(ct2,rst)----模式1
	begin	
		if ct2'event and ct2='0' then
			if rst='0' then
				if cnt3_1=99 then
					cnt3_1<=(others=>'0');
				else
					cnt3_1<=cnt3_1+1;
				end if;
			else
				cnt3_1<=(others=>'0');
			end if;
		end if;
	end process; 
	process(ct1,rst)---模式2
	begin	
		if ct1'event and ct1='0' then
			if rst='0' then
				if cnt3_2=99 then
					cnt3_2<=(others=>'0');
				else
					cnt3_2<=cnt3_2+1;
				end if;
			else
				cnt3_2<=(others=>'0');
			end if;
		end if;
	end process;
	process(ct3,rst)---模式3
	begin	
		if ct3'event and ct3='0' then
			if rst='0' then
				if cnt3_3=99 then
					cnt3_3<=(others=>'0');
				else
					cnt3_3<=cnt3_3+1;
				end if;
			else
				cnt3_3<=(others=>'0');
			end if;
		end if;
	end process;
	--  --  --  --根据计数器状态确定当前模式的输出
	process(clk_dis,cnt1,cnt3_1)
	begin
		if clk_dis'event and clk_dis='1' then
			if cnt1<cnt3_1 then 
				regout1<='1';
			else 
				regout1<='0';
			end if;
		end if;	 
	end process;
	process(clk_dis,cnt1,cnt3_2)
	begin
		if clk_dis'event and clk_dis='1' then
			if cnt1<cnt3_2 then 
				regout2<='1';
			else 
				regout2<='0';
			end if;
		end if;
	end process;
	process(clk_dis,cnt1,cnt3_3)
	begin
		if clk_dis'event and clk_dis='1' then
			if cnt1<cnt3_3 then 
				regout3<='1';
			else 
				regout3<='0';
			end if;	 
		end if;
	end process;
	--  --  --  --  --  --计数器中间衍生触发信号
	c1<=cnt1(6);
	ct3<=ct1 when otsel3='0' else ct1_2 when otsel3='1';
	c3_1<=cnt3_1(6);
	c3_2<=cnt3_2(6);
	c3_3<=cnt3_3(6);
	--  --  --  --  --  --由当前呼/吸状态决定下一状态是吸/呼
	process(c3_1)
	begin
		if c3_1'event and c3_1='0' then
			otsel1<=not otsel1;
		end if;
	end process;
	process(c3_2)
	begin
		if c3_2'event and c3_2='0' then
			otsel2<=not otsel2;
		end if;
	end process;
	process(c3_3)
	begin
		if c3_3'event and c3_3='0' then
			otsel3<=not otsel3;
		end if;
	end process;
	process(otsel1,regout1)----模式1输出
	begin
		if otsel1='0' then
			m1_bout<=regout1;
		elsif otsel1='1' then
			m1_bout<=not regout1;
		else null;
		end if;
	end process;
	process(otsel2,regout2)----模式2输出
	begin
		if otsel2='0' then
			m2_bout<=regout2;
		elsif otsel2='1' then
			m2_bout<=not regout2;
		else null;
		end if;
	end process;	
	process(otsel3,regout3)-----模式3输出，模式4相当于3的反（不考虑时序情况）
	begin
		if otsel3='0' then
			m3_bout<=regout3;
			m4_bout<=not regout3;
		elsif otsel3='1' then
			m3_bout<=not regout3;
			m4_bout<=regout3;
		else null;
		end if;
	end process;
	led_out<=led;
end Behavioral;
